<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Void Runner</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Cormorant+Garamond:wght@300&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #080808;
      --fg: #f0f0f0;
      --dim: #444;
      --mid: #aaa;
      --accent: #fff;
      --font: 'Share Tech Mono', monospace;
    }

    body {
      background: var(--bg);
      color: var(--fg);
      font-family: var(--font);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      user-select: none;
    }

    /* Scanline effect */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.08) 2px,
        rgba(0,0,0,0.08) 4px
      );
      pointer-events: none;
      z-index: 100;
    }

    /* Stars background */
    .stars {
      position: fixed;
      inset: 0;
      overflow: hidden;
      z-index: 0;
    }

    .star {
      position: absolute;
      background: #fff;
      border-radius: 50%;
      animation: starMove linear infinite;
    }

    @keyframes starMove {
      from { transform: translateX(0); opacity: 1; }
      to   { transform: translateX(-100vw); opacity: 0; }
    }

    /* Back link */
    .back-link {
      position: fixed;
      top: 1.5rem;
      left: 1.5rem;
      font-family: var(--font);
      font-size: 0.65rem;
      letter-spacing: 0.15em;
      color: var(--dim);
      text-decoration: none;
      text-transform: uppercase;
      z-index: 50;
      transition: color 0.2s;
    }
    .back-link:hover { color: var(--fg); }

    /* Page title */
    .page-title {
      position: fixed;
      top: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.62rem;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: var(--dim);
      z-index: 50;
    }

    /* Game wrapper */
    .game-wrap {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    /* HUD */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 700px;
      max-width: 92vw;
      font-size: 0.68rem;
      letter-spacing: 0.15em;
      color: var(--mid);
      padding: 0 2px;
    }

    .hud span { color: var(--fg); }

    /* Canvas */
    canvas {
      display: block;
      border: 1px solid #222;
      image-rendering: pixelated;
      background: #000;
      box-shadow:
        0 0 0 1px #111,
        0 0 40px rgba(255,255,255,0.03),
        0 20px 60px rgba(0,0,0,0.8);
    }

    /* Overlay screens */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1.25rem;
      background: rgba(0,0,0,0.82);
      z-index: 20;
      transition: opacity 0.3s;
    }

    .overlay.hidden { display: none; }

    .overlay-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: 2.8rem;
      font-weight: 300;
      letter-spacing: 0.08em;
      color: var(--fg);
      line-height: 1;
    }

    .overlay-sub {
      font-size: 0.62rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--dim);
    }

    .overlay-score {
      font-size: 0.72rem;
      letter-spacing: 0.15em;
      color: var(--mid);
    }

    .overlay-score span { color: var(--fg); }

    .btn {
      margin-top: 0.5rem;
      padding: 0.6rem 2rem;
      background: transparent;
      border: 1px solid #333;
      color: var(--mid);
      font-family: var(--font);
      font-size: 0.65rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s, color 0.2s, background 0.2s;
    }

    .btn:hover {
      border-color: var(--fg);
      color: var(--fg);
      background: rgba(255,255,255,0.04);
    }

    /* Controls hint */
    .controls {
      font-size: 0.58rem;
      letter-spacing: 0.12em;
      color: var(--dim);
      text-transform: uppercase;
      text-align: center;
    }

    /* Pixel heart lives */
    .lives-display {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .heart {
      width: 10px;
      height: 10px;
      background: var(--fg);
      clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 50%, 50% 100%, 0% 50%, 0% 25%);
      transition: opacity 0.3s;
    }

    .heart.lost { opacity: 0.12; }
  </style>
</head>
<body>

  <!-- Stars -->
  <div class="stars" id="stars"></div>

  <!-- Nav -->
  <a href="/" class="back-link">← Back</a>
  <div class="page-title">Void Runner</div>

  <!-- Game -->
  <div class="game-wrap">
    <div class="hud">
      <div>SCORE: <span id="scoreDisplay">00000</span></div>
      <div>BEST: <span id="bestDisplay">00000</span></div>
      <div style="display:flex;align-items:center;gap:8px;">
        LIVES:
        <div class="lives-display" id="livesDisplay">
          <div class="heart" id="h1"></div>
          <div class="heart" id="h2"></div>
          <div class="heart" id="h3"></div>
        </div>
      </div>
    </div>

    <div style="position:relative;">
      <canvas id="gameCanvas" width="700" height="220"></canvas>

      <!-- Start screen -->
      <div class="overlay" id="startScreen">
        <div class="overlay-title">Void Runner</div>
        <div class="overlay-sub">A spaceship survival game</div>
        <button class="btn" id="startBtn">[ Launch ]</button>
        <div class="controls">Space / Tap — Jump &nbsp;·&nbsp; Double Space — Double Jump</div>
      </div>

      <!-- Game over screen -->
      <div class="overlay hidden" id="gameOverScreen">
        <div class="overlay-title">Game Over</div>
        <div class="overlay-score">Score: <span id="finalScore">0</span> &nbsp;·&nbsp; Best: <span id="finalBest">0</span></div>
        <button class="btn" id="restartBtn">[ Restart ]</button>
      </div>
    </div>

    <div class="controls">Space / Click to jump &nbsp;·&nbsp; Double tap for double jump</div>
  </div>

<script>
// ── Stars background ──
const starsEl = document.getElementById('stars');
for (let i = 0; i < 80; i++) {
  const s = document.createElement('div');
  s.className = 'star';
  const size = Math.random() * 2 + 0.5;
  s.style.cssText = `
    width:${size}px; height:${size}px;
    top:${Math.random()*100}vh;
    left:${Math.random()*100 + 100}vw;
    animation-duration:${Math.random()*8+4}s;
    animation-delay:-${Math.random()*10}s;
    opacity:${Math.random()*0.7+0.1};
  `;
  starsEl.appendChild(s);
}

// ── Canvas setup ──
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// ── Game state ──
let state = 'idle'; // idle | playing | dead
let score = 0;
let best = parseInt(localStorage.getItem('voidrunner_best') || '0');
let lives = 3;
let frameCount = 0;
let speed = 5;
let jumpCount = 0;
let invincible = false;
let invincibleTimer = 0;
let particles = [];

// ── Ship ──
const ship = {
  x: 90,
  y: H - 60,
  w: 32,
  h: 18,
  vy: 0,
  gravity: 0.55,
  jumpForce: -11,
  grounded: true,
  thrusterFrame: 0,
};
const GROUND = H - 44;

// ── Obstacles ──
let obstacles = [];
let obstacleTimer = 0;
let obstacleInterval = 90;

// ── Stars (parallax) ──
let bgStars = [];
for (let i = 0; i < 60; i++) {
  bgStars.push({
    x: Math.random() * W,
    y: Math.random() * (H - 40),
    size: Math.random() * 1.5 + 0.3,
    speed: Math.random() * 1.5 + 0.3,
    opacity: Math.random() * 0.6 + 0.1,
  });
}

// ── HUD elements ──
const scoreDisplay = document.getElementById('scoreDisplay');
const bestDisplay  = document.getElementById('bestDisplay');
const finalScore   = document.getElementById('finalScore');
const finalBest    = document.getElementById('finalBest');
const hearts       = [document.getElementById('h1'), document.getElementById('h2'), document.getElementById('h3')];

function updateHUD() {
  scoreDisplay.textContent = String(score).padStart(5, '0');
  bestDisplay.textContent  = String(best).padStart(5, '0');
  hearts.forEach((h, i) => {
    h.classList.toggle('lost', i >= lives);
  });
}

// ── Draw ship (pixel art style) ──
function drawShip(x, y, flicker) {
  if (flicker && Math.floor(Date.now() / 80) % 2 === 0) return;

  ctx.save();
  const px = Math.floor(x);
  const py = Math.floor(y);

  // Thruster flame
  ship.thrusterFrame = (ship.thrusterFrame + 1) % 6;
  const flameH = ship.thrusterFrame < 3 ? 10 : 7;
  const grad = ctx.createLinearGradient(px - 6, py + 8, px - 6 - flameH, py + 8);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.4, 'rgba(200,200,200,0.5)');
  grad.addColorStop(1, 'rgba(100,100,100,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(px - 4, py + 5);
  ctx.lineTo(px - 4 - flameH, py + 8);
  ctx.lineTo(px - 4, py + 11);
  ctx.closePath();
  ctx.fill();

  // Main body
  ctx.fillStyle = '#ffffff';
ctx.fillRect(px - 4, py + 4, 20, 10);
ctx.strokeStyle = '#aaaaaa';
ctx.lineWidth = 1;
ctx.strokeRect(px - 4, py + 4, 20, 10);

  // Cockpit
  ctx.fillStyle = '#000';
  ctx.fillRect(px + 10, py + 5, 8, 8);
  ctx.fillStyle = '#ccc';
  ctx.fillRect(px + 11, py + 6, 6, 6);

  // Wing top
ctx.fillStyle = '#dddddd';
ctx.beginPath();
ctx.moveTo(px + 2, py + 4);
ctx.lineTo(px + 8, py - 2);
ctx.lineTo(px + 16, py + 4);
ctx.closePath();
ctx.fill();

// Wing bottom
ctx.beginPath();
ctx.moveTo(px + 2, py + 14);
ctx.lineTo(px + 8, py + 20);
ctx.lineTo(px + 16, py + 14);
ctx.closePath();
ctx.fill();

  // Engine block
  ctx.fillStyle = '#888';
  ctx.fillRect(px - 4, py + 6, 6, 6);

  // Pixel highlights
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillRect(px, py + 5, 8, 1);

  ctx.restore();
}

// ── Draw obstacle ──
function drawObstacle(obs) {
  ctx.save();
  const px = Math.floor(obs.x);
  const py = Math.floor(obs.y);

  if (obs.type === 'asteroid') {
    // Pixel asteroid
    ctx.fillStyle = '#888';
    ctx.fillRect(px + 4, py, obs.w - 8, obs.h);
    ctx.fillRect(px, py + 4, obs.w, obs.h - 8);
    ctx.fillRect(px + 2, py + 2, obs.w - 4, obs.h - 4);
    // Highlight
    ctx.fillStyle = '#bbb';
    ctx.fillRect(px + 4, py + 2, 4, 2);
    ctx.fillRect(px + 2, py + 4, 2, 4);
    // Dark pixels
    ctx.fillStyle = '#444';
    ctx.fillRect(px + obs.w - 6, py + obs.h - 6, 4, 4);
  } else if (obs.type === 'missile') {
    // Enemy missile
    ctx.fillStyle = '#ccc';
    ctx.fillRect(px, py + 3, obs.w - 4, 6);
    ctx.fillStyle = '#fff';
    ctx.fillRect(px + obs.w - 6, py + 4, 6, 4);
    ctx.fillStyle = '#666';
    ctx.fillRect(px, py + 4, 4, 4);
    // Blinking light
    if (Math.floor(Date.now() / 200) % 2 === 0) {
      ctx.fillStyle = '#fff';
      ctx.fillRect(px + obs.w - 4, py + 5, 2, 2);
    }
  } else if (obs.type === 'satellite') {
    // Satellite (tall obstacle)
    ctx.fillStyle = '#999';
    ctx.fillRect(px + 8, py, 8, obs.h);
    ctx.fillStyle = '#ccc';
    ctx.fillRect(px, py + obs.h / 2 - 4, obs.w, 8);
    ctx.fillStyle = '#555';
    ctx.fillRect(px + 10, py + 2, 4, obs.h - 4);
    // Solar panels
    ctx.fillStyle = '#777';
    ctx.fillRect(px + 1, py + obs.h / 2 - 3, 7, 6);
    ctx.fillRect(px + obs.w - 8, py + obs.h / 2 - 3, 7, 6);
    // Panel lines
    ctx.fillStyle = '#555';
    for (let i = 0; i < 3; i++) {
      ctx.fillRect(px + 2 + i * 2, py + obs.h / 2 - 2, 1, 4);
      ctx.fillRect(px + obs.w - 7 + i * 2, py + obs.h / 2 - 2, 1, 4);
    }
  }

  ctx.restore();
}

// ── Spawn obstacle ──
function spawnObstacle() {
  const types = ['asteroid', 'asteroid', 'missile', 'satellite'];
  const type = types[Math.floor(Math.random() * types.length)];

  let obs = { type, x: W + 20, passed: false };

  if (type === 'asteroid') {
    const size = 20 + Math.random() * 20;
    obs.w = size; obs.h = size;
    // Ground level or floating
    const floating = Math.random() < 0.3;
    obs.y = floating
      ? GROUND - size - 40 - Math.random() * 30
      : GROUND - size;
  } else if (type === 'missile') {
    obs.w = 40; obs.h = 12;
    obs.y = GROUND - 12 - Math.random() * 60;
  } else if (type === 'satellite') {
    obs.w = 24; obs.h = 50;
    obs.y = GROUND - 50;
  }

  obstacles.push(obs);
}

// ── Particles ──
function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = Math.random() * 3 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: 1,
      decay: Math.random() * 0.04 + 0.02,
      size: Math.random() * 3 + 1,
      color,
    });
  }
}

function updateParticles() {
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.08;
    p.life -= p.decay;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(Math.floor(p.x), Math.floor(p.y), Math.floor(p.size), Math.floor(p.size));
    ctx.restore();
  });
}

// ── Jump ──
function jump() {
  if (state !== 'playing') return;
  if (jumpCount < 2) {
    ship.vy = ship.jumpForce;
    ship.grounded = false;
    jumpCount++;
    spawnParticles(ship.x, ship.y + ship.h, 6, '#aaa');
  }
}

// ── Collision ──
function checkCollision(obs) {
  const margin = 5;
  return (
    ship.x + margin < obs.x + obs.w &&
    ship.x + ship.w - margin > obs.x &&
    ship.y + margin < obs.y + obs.h &&
    ship.y + ship.h - margin > obs.y
  );
}

// ── Main loop ──
function gameLoop() {
  if (state !== 'playing') return;

  frameCount++;
  ctx.clearRect(0, 0, W, H);

  // Background
ctx.fillStyle = '#0d0d1a';
ctx.fillRect(0, 0, W, H);
  // Parallax stars
  bgStars.forEach(s => {
    s.x -= s.speed * (speed / 5);
    if (s.x < 0) s.x = W + 2;
    ctx.globalAlpha = s.opacity;
    ctx.fillStyle = '#fff';
    ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.ceil(s.size), Math.ceil(s.size));
  });
  ctx.globalAlpha = 1;

  // Ground
  ctx.fillStyle = '#2a2a2a';
ctx.fillRect(0, H - 40, W, 40);
  ctx.fillStyle = '#333';
  ctx.fillRect(0, H - 41, W, 1);
  // Ground details
  for (let gx = (frameCount * speed) % 40; gx < W; gx += 40) {
    ctx.fillStyle = '#222';
    ctx.fillRect(Math.floor(gx), H - 38, 20, 1);
  }

  // Speed increase
  speed = 5 + Math.floor(score / 300) * 0.5;
  obstacleInterval = Math.max(55, 90 - Math.floor(score / 200) * 3);

  // Score
  score++;
  if (score > best) {
    best = score;
    localStorage.setItem('voidrunner_best', best);
  }
  updateHUD();

  // Ship physics
  ship.vy += ship.gravity;
  ship.y += ship.vy;

  if (ship.y >= GROUND - ship.h) {
    ship.y = GROUND - ship.h;
    ship.vy = 0;
    ship.grounded = true;
    jumpCount = 0;
  }

  // Obstacles
  obstacleTimer++;
  if (obstacleTimer >= obstacleInterval) {
    spawnObstacle();
    obstacleTimer = 0;
  }

  obstacles.forEach(obs => {
    obs.x -= speed;

    // Score point
    if (!obs.passed && obs.x + obs.w < ship.x) {
      obs.passed = true;
      spawnParticles(ship.x + ship.w, ship.y + ship.h / 2, 4, '#fff');
    }

    drawObstacle(obs);

    // Collision
    if (!invincible && checkCollision(obs)) {
      lives--;
      updateHUD();
      spawnParticles(ship.x + ship.w / 2, ship.y + ship.h / 2, 20, '#fff');
      if (lives <= 0) {
        endGame();
        return;
      }
      // Brief invincibility
      invincible = true;
      invincibleTimer = 120;
    }
  });

  // Remove off-screen obstacles
  obstacles = obstacles.filter(o => o.x + o.w > -10);

  // Invincibility countdown
  if (invincible) {
    invincibleTimer--;
    if (invincibleTimer <= 0) invincible = false;
  }

  // Particles
  updateParticles();
  drawParticles();

  // Ship
  drawShip(ship.x, ship.y, invincible);

  // Speed indicator
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(W - 80, 8, 72, 14);
  ctx.fillStyle = '#333';
  ctx.font = '9px Share Tech Mono';
  ctx.fillText(`SPD ${speed.toFixed(1)}`, W - 75, 19);

  requestAnimationFrame(gameLoop);
}

// ── Start ──
function startGame() {
  state = 'playing';
  score = 0;
  lives = 3;
  speed = 5;
  obstacles = [];
  particles = [];
  obstacleTimer = 0;
  invincible = false;
  ship.y = GROUND - ship.h;
  ship.vy = 0;
  ship.grounded = true;
  jumpCount = 0;
  frameCount = 0;
  updateHUD();
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  gameLoop();
}

function endGame() {
  state = 'dead';
  finalScore.textContent = score;
  finalBest.textContent = best;
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

// ── Controls ──
document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    if (state === 'idle') startGame();
    else jump();
  }
});

canvas.addEventListener('click', () => {
  if (state === 'idle') startGame();
  else jump();
});

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// Touch support
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (state === 'idle') startGame();
  else jump();
}, { passive: false });

// ── Draw idle screen ──
function drawIdle() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  bgStars.forEach(s => {
    ctx.globalAlpha = s.opacity;
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, H - 40, W, 40);
  ctx.fillStyle = '#333';
  ctx.fillRect(0, H - 41, W, 1);
  drawShip(ship.x, ship.y, false);
  updateHUD();
}

drawIdle();
</script>
</body>
</html>
